module Homework2 where
import Test.QuickCheck
-- Function prob1
-- @type    prob1 :: (a -> a) -> (a -> Bool) -> [a] -> [a]
-- @param   (a -> a)
-- @param   (a -> Bool)
-- @param   [a]
-- @output  [a]
-- @description: Takes two functions and a list. One function returns a boolean value given some parameter. If that function returns true, the second function is applied. Returns
--    the list generated by applying these functions on the whole list with map and filter.
-- listComp f p xs = [ f x | x <- xs, p x]
prob1 :: (a -> a) -> (a -> Bool) -> [a] -> [a]
prob1 f p xs = map f (filter p xs) 

-- Function prob2
-- @type   prob2 :: Integer -> [Integer]
-- @param  Integer
-- @output [Integer]
-- @description: Takes an integer. If the number is negative, returns the empty list. Otherwise, it recurses down until the given number is less than 10. At that point it 
--    returns that number in a list, concatenating it with the number from the preceding calls modulo 10.
prob2 x
  | x < 0     = []
  | x < 10    = [x]
  | otherwise = prob2 (x `div` 10) ++ [x `mod` 10]


-- Function prob3
-- @type   prob3 :: Integer -> [Integer]
-- @param  Integer
-- @output [Integer]
-- @description: Just calls reverse on the results of calling prob2 on the given number.
prob3 :: Integer -> [Integer]
prob3 x = reverse(prob2 x)

--ANOTHER WAY OF DOING IT.
-- @description: Takes an integer. If the number is negative, returns the empty list. Otherwise, it recurses down until the given number is less than 10. At that point it 
--    returns that number in a list, prepending it with the number from the preceding calls modulo 10.
--prob3 x
--  | x < 0     = []
--  | x < 10    = [x]
--  | otherwise = (x `mod` 10) : prob3 (x `div` 10)


-- Function prob4
-- @type     prob4 :: [Integer] -> [Integer]
-- @param   [Integer]
-- @output  [Integer]
-- @description: Takes a list of integers. Checks against 3 base cases and returns the appropriate list, otherwise if the list is larger than 3 numbers, it recursively 
--    takes the last two numbers off of the end, multiplying the 2nd to last number by 2 until it reaches one of the 3 base cases.
prob4 :: [Integer] -> [Integer]
prob4 []      = []
prob4 x
  | length x == 1 = x
  | length x == 2 =  ((head x) * 2) : [last x]
  | length x == 3 = (head x) : ((head(tail x)) * 2) : [last x]
  | otherwise     = (prob4 ((init . init) x)) ++ [((last . init) x) * 2] ++ [(last x)]

-- Function prob5
-- @type    [Integer] -> Integer
-- @param   [Integer]
-- @output  Integer
-- @description: Takes a list of Integers. Uses a fold left with an anonymous function to sum up the value of each numbers' digits over the list by using another 
--    fold left that sums up the list created by prob2 of the individual digits of each number in the list. Essentially, it's summing the digits of each number, 
--    then summing those sums.
prob5 :: [Integer] -> Integer
prob5 [] = 0
prob5 xs = foldl (\acc1 x -> acc1 + (foldl (\acc2 y -> acc2 + y) 0 (prob2 x))) 0 xs




        
---------------------------------------------              
--               Unit Tests                --
---------------------------------------------  
test_prob1 :: IO ()
test_prob1  = do
  putStrLn "Problem 1 Results:"
  prob1_test1
  prob1_test2
test_prob2 :: IO ()
test_prob2  = do
  putStrLn "Problem 2 Results:"
  prob2_test1
  prob2_test2
test_prob3 :: IO ()
test_prob3  = do
  putStrLn "Problem 3 Results:"
  prob3_test1
test_prob4 :: IO ()
test_prob4  = do
  putStrLn "Problem 4 Results:"
  prob4_test1
  prob4_test2
test_prob5 :: IO ()
test_prob5  = do
  putStrLn "Problem 5 Results:"
  prob5_test1
test_probs :: IO ()
test_probs  = do
  putStrLn "-------- All Problem Results --------"
  test_prob1
  test_prob2
  test_prob3
  test_prob4
  test_prob5
  putStrLn "-------------------------------------"
prob1_test1 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob1_property1
  where
    prob1_property1 :: [Integer] -> Bool
    prob1_property1 xs = lComp (+1) (even) xs == prob1 (+1) (even) xs
      where lComp f p xs = [ f x | x <- xs, p x]
prob1_test2 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob1_property2
  where
    prob1_property2 :: [Int] -> Bool
    prob1_property2 xs = lComp (*2) (odd) xs == prob1 (*2) (odd) xs
      where lComp f p xs = [ f x | x <- xs, p x]
prob2_test1 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob2_property1
  where
    prob2_property1 :: Integer -> Bool
    prob2_property1 xs = abs xs == (go1 . prob2) (abs xs)
      where go1 :: [Integer] -> Integer
            go1 xs
              | (null xs) = 0
              | otherwise = let pos = filter (> -1) xs
                            in  read (foldl (++) "" $ map show pos) :: Integer
prob2_test2 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob2_property2
  where
    prob2_property2 :: Integer -> Bool
    prob2_property2 xs  = prob2 xs == prob2_dual xs
      where prob2_dual :: Integer -> [Integer]
            prob2_dual x
              | x < 0      = []
              | otherwise  = map go' $ show x
              where go' '0' = 0
                    go' '1' = 1
                    go' '2' = 2
                    go' '3' = 3
                    go' '4' = 4
                    go' '5' = 5
                    go' '6' = 6
                    go' '7' = 7
                    go' '8' = 8
                    go' '9' = 9
prob3_test1 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob3_property1
  where
    prob3_property1 :: Integer -> Bool
    prob3_property1 xs  = prob3 xs == go1 xs
      where go1 :: Integer -> [Integer]
            go1 n | n < 0      = []
                  | otherwise  = reverse $ map go' $ show n
              where go' '0' = 0
                    go' '1' = 1
                    go' '2' = 2
                    go' '3' = 3
                    go' '4' = 4
                    go' '5' = 5
                    go' '6' = 6
                    go' '7' = 7
                    go' '8' = 8
                    go' '9' = 9
prob4_test1 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob4_property1
  where
    prob4_property1 :: Integer -> Integer -> Integer -> Integer -> Bool
    prob4_property1 w x y z = [(w + w),x, (y + y), z] == prob4 [w,x,y,z]
prob4_test2 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob4_property2
  where
    prob4_property2 :: Integer -> Integer -> Integer -> Integer -> Integer -> Bool
    prob4_property2 v w x y z = [v, (w + w), x, (y + y), z] == prob4 [v,w,x,y,z]
prob5_test1 = quickCheckWith (stdArgs {maxSuccess = 1000}) prob5_property
  where
    prob5_property :: [Integer] -> Bool
    prob5_property xs = prob5 (map (abs) xs) == go' xs
    go' :: [Integer] -> Integer 
    go' is = go1 (map (abs) is) 0
      where go1 :: [Integer] -> Integer -> Integer
            go1 [] n     = n
            go1 (x:xs) n | (x < 10)   = go1 xs (x + n)
                         | (x > 9)    = go1 xs ((sum (go2 x)) + n)
                         | otherwise  = go1 xs n 
            go2 :: Integer -> [Integer]
            go2 x
              | x < 0      = []
              | otherwise  = map go3 $ show x
            go3 :: Char -> Integer
            go3 '0' = 0
            go3 '1' = 1
            go3 '2' = 2
            go3 '3' = 3
            go3 '4' = 4
            go3 '5' = 5
            go3 '6' = 6
            go3 '7' = 7
            go3 '8' = 8
            go3 '9' = 9
